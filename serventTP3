#!/usr/bin/python

import sys
import socket
import struct

# Campo
CLIREQ = 1
QUERY = 2
TTL = 3
RESPONSE = 3

# Recebendo porta
PORT = int(sys.argv[1])

# Arquivo
arquivo = sys.argv[2]

# Contador
contMSG = 0

# IP e porta 
UDP_IP = socket.gethostbyname(socket.gethostname())
UDP_PORT = PORT
print UDP_IP

# Socket UDP
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((UDP_IP, UDP_PORT))

# Arrays
dicionario = []
arrayVizinhos = []
mensagensLidas = []

# Vizinhos 
vizinhos = sys.argv[3:]
for i in vizinhos:
  arrayVizinhos.append(i)

for i in arrayVizinhos:
  print i

# Criando o dicionario
chaves = open(arquivo,'r') 
for line in chaves: 
  if not line.startswith("#"):
    dicionario.append(line.strip('\n'))

for i in dicionario:
  print i.split()[0], i.split()[1], i.split()[2], i.split()[3]

# Aguardando mensagens
while True:
  data, addr = sock.recvfrom(1024) 
  print "received message:", data
  print addr
  dados = struct.unpack('>H', data[0:2])[0]
  print data[0:2], dados
  if dados == CLIREQ:
    print "CLIREQ"
    # Montar QUERY
    contMSG = contMSG + 1
    tratarIP = socket.inet_aton(addr[0])
    contador = struct.pack('>I', contMSG)
    portaString = struct.pack('>H', int(addr[1]))
    query = struct.pack('>H', QUERY) + struct.pack('>H', TTL) + tratarIP + portaString + contador + data[2:]
    print struct.unpack('>H', query[0:2])[0],struct.unpack('>H', query[2:4])[0], struct.unpack('>H', query[8:10])[0],struct.unpack('>H', query[10:12])[0],query[14:]
    print query
    print "enviando aos vizinhos"
    # Envia para todos os vizinhos
    for i in arrayVizinhos:
      #print i.split(':')[0], i.split(':')[1]
      ipVizinho = i.split(':')[0]
      portaVizinho = int(i.split(':')[1])
      sock.sendto(query, (ipVizinho,portaVizinho))
  if dados == QUERY:
    print "QUERY"
    # Adicionando a mensagem a array de Mensagens
    ipCliente = socket.inet_ntoa(data[4:8])
    portaCliente = struct.unpack('>H', query[8:10])[0]
    sequenciaCliente = struct.unpack('>H', query[10:12])[0]
    chave = data[14:]
    mensagem = ipCliente + portaCliente + sequenciaCliente + chave
    if mensagem not in mensagensLidas:
      # Adiciona a mensagem as mensagens lidas afim de evitar repeticoes
      mensagensLidas.append(mensagem)
      # E confere se a chave esta no seu dicionario local
      for i in dicionario:
        chaveDicionario = i.split()[0]
        # Se encontrar a chave no dicionario
        if chave == chaveDicionario:
 	  response = struct.pack('>H', RESPONSE) + i.split()
   	  sock.sendto(response, (ipCliente,portaCliente))
    # Se repetida, reenvia para os vizinhos apenas se o TTL for maior que zero
    else:
      novoTTL = int(struct.unpack('>H', query[2:4])[0])
      novoTTL = novoTTL - 1
      if novoTTL > 0:
	novaMensagem = data[0:2] + struct.pack('>H', novoTTL) + data[4:]
	for i in arrayVizinhos:
	  ipVizinho = i.split(':')[0]
          portaVizinho = int(i.split(':')[1])
	  # Nao pode enviar para quem o enviou a mensagem
	  if ipVizinho != addr[0] or portaVizinho != addr[1]:
	    sock.sendto(novaMensagem, (ipVizinho,portaVizinho))
  
